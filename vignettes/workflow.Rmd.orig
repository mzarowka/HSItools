---
title: "Basic workflow"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(HSItools)
library(patchwork)
library(terra)
library(dplyr)
library(tidyr)
library(ggplot2)
```

Here, we present a basic workflow for a single core. It is assumed that the output of the `run_core()` function is available and stored on the disk.

We're using some internal data here, substantially reducing spatial resolution.

## Basic workflow

```{r load-hsitools-output}
# Load run_core() output

core <- readRDS("C:/GitHub/data/STL14_1A_28C_top_2022-11-11_16-30-51/HSItools_core.rds")
```

## Preprocessing

### Normalization

Before any spectral indices and properties are calculated, normalizing the data and expressing it as a reflectance is necessary.

```{r prepare-core, warning=FALSE}
# Here we use run_core() output, so further function arguments are filled automatically.
# Output is written to the file.
reflectance <- core |>
  prepare_core()
```

We can plot the RGB preview at this stage.

```{r reflectance_rgb, warning=FALSE}
plot_raster_rgb(reflectance)
```

### Spectral smoothing

Applying spectral smoothing, such as the Savitzky-Golay spectral filter, is a good idea. Spurious, random peaks and through do not influence the calculation results.

```{r sav-gol, warning=FALSE}
reflectance_smooth <- reflectance |>
  # Specify the file extension
  filter_savgol()
```

We can plot the RGB preview at this stage, too.

```{r savgol_rgb, warning=FALSE}
plot_raster_rgb(reflectance_smooth)
```

### Peek into spectra

```{r peek-spectra}
# Spectral profile from the entire ROI
reflectance_sp <- reflectance |>
  # Use HSItools function to extract the profile
  extract_spectral_profile() |>
  # Pivot longer so for plotting
  tidyr::pivot_longer(
    dplyr::everything(),
    names_to = "band",
    values_to = "reflectance",
    names_transform = readr::parse_number)

# Peek into data
head(reflectance_sp)

# Spectral profile from the entire ROI
reflectance_smooth_sp <- reflectance_smooth |>
  # Use HSItools function to extract the profile
  extract_spectral_profile() |>
  # Pivot longer so for plotting
  tidyr::pivot_longer(
    dplyr::everything(),
    names_to = "band",
    values_to = "reflectance_sg",
    names_transform = readr::parse_number)

# Peek into data
head(reflectance_smooth_sp)

# Plot both profiles data
sp_compare <- dplyr::left_join(
  reflectance_sp,
  reflectance_smooth_sp,
  dplyr::join_by(band)) |>
  tidyr::pivot_longer(
    -band,
    names_to = "type",
    values_to = "reflectance") |>
  ggplot2::ggplot(aes(band, reflectance, color = type)) +
  ggplot2::geom_line() +
  ggplot2::scale_x_continuous(breaks = scales::pretty_breaks()) +
  ggplot2::labs(
    x = "Wavelength (nm)",
    y = "Reflectance",
    color = "Spectrum type") +
  ggplot2::theme_bw() +
  ggplot2::theme(legend.position = "bottom")

# Print
sp_compare
```

Both plots look similar at this scale except for noisy UV and blue. We can zoom it, preferably into a flat region.

```{r zoom-spectra}
# Zoom by limits
sp_compare +
  ggplot2::coord_cartesian(
    xlim = c(600, 650),
    ylim = c(0.1330, 0.1360))
```

### Continuum removal

We can process our data further by removing the continuum, which follows the rule of dividing the spectrum by its bounding box. This way, the spectrum becomes flatter.

```{r remove-continuum}
# Calculate reflectance with removed continuum
# Use the smoothed spectrum
reflectance_cr <- reflectance_smooth |>
  remove_continuum()
```

## Index calculation

At this point, it is OK to calculate selected indices or proxies.

Mean reflectance (Rmean)

```{r rmean}
rmean <- reflectance_smooth |>
  calculate_rmean()
```

```{r rmean-plot}
plot_rmean <- rmean |>
  plot_raster_proxy(
    hsi_index = names(rmean),
    palette = "mako")

# Print
plot_rmean
```

### Relative Absorption Band Depth (RABD).

There are variations to the RABD calculation, but generally, the results are not drastically different. Let's calculate one of the most common indices to estimate the total chloropigments-*a* - RABD~660670~.

You can use predefined values or provide them manually. Let's calculate three different flavors.

The name of the output informs you about the calculated proxy and additional modifications to the reflectance file; here, we see that it was calculated with Savitzky-Golay smoothed reflectance.

#### Variant 1: max

In this variant, for each pixel, a minimum reflectance is found in the trough and flexibly used for calculations.

```{r rabd-max}
rabd660670max <- reflectance_smooth |>
  # Calculate max variant
  calculate_rabd(
    edges = proxies$rabd_b660b670$edges,
    trough = proxies$rabd_b660b670$trough,
    rabd_name = proxies$rabd_b660b670$proxy_name,
    rabd_type = "max")
```

Plot. Hyperspectral imaging data is most fun when visualized. We use "viridis" palettes.

```{r rabd-max-plot}
# Prepare the plot
plot_rabd660670max <- rabd660670max |>
  plot_raster_proxy(
    hsi_index = names(rabd660670max),
    palette = "viridis")

# Print
plot_rabd660670max
```

#### Variant 2: strict

This classic variant supplies a specific wavelength to calculate RABD for every pixel.

```{r rabd-strict}
rabd665 <- reflectance_smooth |>
  # Calculate max variant
  calculate_rabd(
    edges = proxies$rabd_b660b670$edges,
    trough = 665,
    rabd_name = proxies$rabd_b660b670$proxy_name,
    rabd_type = "strict")
```

```{r rabd-strict-plot}
# Prepare the plot
plot_rabd665 <- rabd665 |>
  plot_raster_proxy(
    hsi_index = names(rabd665),
    palette = "viridis")

# Print
plot_rabd665
```

#### Variant 3: midpoint

This is variant 2 (strict), with the added shortcut of always finding the middle point between the through edges.

```{r rabd-mid}
rabd660670mid <- reflectance_smooth |>
  # Calculate max variant
  calculate_rabd(
    edges = proxies$rabd_b660b670$edges,
    trough = proxies$rabd_b660b670$trough,
    rabd_name = proxies$rabd_b660b670$proxy_name,
    rabd_type = "mid")
```

```{r rabd-mid-plot}
# Prepare the plot
plot_rabd660670mid <- rabd660670mid |>
  plot_raster_proxy(
    hsi_index = names(rabd660670mid),
    palette = "viridis")

# Print
plot_rabd660670mid
```

#### Compare

We can compare these three plots side by side. We're using `patchwork`.

```{r rabd-compare}
plot_rabd660670max + plot_rabd665 + plot_rabd660670mid + patchwork::plot_layout(nrow = 1)
```

Similar, but not identical. As expected!

### Relative Absorption Band Area (RABA)

### Band ratios

Another popular and straightforward indices are band ratios, where reflectance at the wavelength X is divided by reflectance at the wavelength Y.

```{r ratio}
ratio_570630 <- reflectance_smooth |>
  calculate_band_ratio(
    edges = proxies$ratio_b570b630$edges,
    ratio_name = proxies$ratio_b570b630$proxy_name)
```

```{r ratio-plot}
plot_ratio570630 <- ratio_570630 |>
  plot_raster_proxy(
    hsi_index = names(ratio_570630),
    palette = "magma")

plot_ratio570630
```

### Band differences

```{r difference}
difference_650675 <- reflectance_smooth |>
  calculate_band_difference(
    difference_name = proxies$diff_b650b675$proxy_name,
    edges = proxies$diff_b650b675$edges)
```

```{r difference-plot}
plot_difference_650675 <- difference_650675 |>
  plot_raster_proxy(
    hsi_index = names(difference_650675),
    palette = "cividis")

plot_difference_650675
```

### Derivatives

```{r}
# derivative_690 <- reflectance_smooth |>
#   calculate_derivative(derivative_name = proxies$deriv_b690)
```

### lambdaREMP

```{r}

```
